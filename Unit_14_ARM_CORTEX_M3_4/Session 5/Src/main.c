/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "../Services/Platform_Types.h"
#include "../Services/stm32f103c6.h"
#include "../Services/Utils.h"
#include "../MCAL/Inc/GPIO.h"
#include "../MCAL/Inc/EXTI.h"
#include "../MCAL/Inc/USART.h"
#include "../MCAL/Inc/SPI.h"
#include "../MCAL/Inc/I2C.h"
#include "../MCAL/Inc/GPTM.h"
#include "../HAL/Inc/LCD.h"
#include "../HAL/Inc/keypad.h"
#include "../HAL/Inc/EEPROM.h"
#include "../HAL/Inc/SevenSegment.h"
#include "../HAL/Inc/Servo.h"
//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-
//									Functions Definitions
//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-

void MainOS();
void TaskA(int a, int b, int c);
void TaskB(int a, int b, int c,int d);

//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-
//									Generic Macros
//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-

#define OS_SET_PSP(addr) 			__asm volatile("mov r0,%0 \n\t"		\
													   "msr PSP,r0" 	\
													   :				\
													   :"r" (addr))

#define OS_SWITCH_SP_to_PSP() 		__asm volatile("mrs r0,CONTROL \n\t"	\
													"orr r0,r0,#0x2 \n\t" 	\
													"msr CONTROL,r0")

#define OS_SWITCH_SP_to_MSP() 		__asm volatile("mrs r0,CONTROL \n\t"	\
												   "and r0,r0,#0x5 \n\t" 	\
												   "msr CONTROL,r0")

#define OS_SWITCH_to_Pri()			__asm volatile("mrs r0,CONTROL \n\t"	\
													"lsr r0,#0x1 \n\t"		\
													"lsl r0,#0x1 \n\t"		\
													"msr CONTROL,r0")

#define OS_SWITCH_to_Unpri()		__asm volatile("mrs r0,CONTROL \n\t"	\
													"orr r0, r0,#0x1 \n\t"	\
													"msr CONTROL,r0")

#define OS_Generate_Exception() 	__asm volatile("SVC #0x3")


enum CPU_AccessLevel
{
	privileged,
	unprivileged
};

enum TaskFlag{
	NoTask_Running,
	TaskA_Running,
	TaskB_Running
};

enum TaskFlag Task_Flag = NoTask_Running;

//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-
//									Global Variables
//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-s

// Linker Script extern Value
extern unsigned int _estack;

// Main Stack Data
#define MAIN_STACK_SIZE		512	//512 bytes

unsigned int _S_MSP = (unsigned int) &_estack;
unsigned int _E_MSP;

// Task A Stack Data
#define TASK_A_STACK_SIZE	100	//100 bytes

unsigned int _S_PSP_TaskA;
unsigned int _E_PSP_TaskA;

// Task B Stack Data
#define TASK_B_STACK_SIZE	100	//100 bytes

unsigned int _S_PSP_TaskB;
unsigned int _E_PSP_TaskB;

//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-
//										ISR Handlers
//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-

void SVC_Handler()
{
	OS_SWITCH_to_Pri();
}

void CallBackFunction(void)
{
	if(Task_Flag == NoTask_Running || Task_Flag == TaskB_Running)
	{
		Task_Flag = TaskA_Running;
	}
	else if(Task_Flag == TaskA_Running)
	{
		Task_Flag = TaskB_Running;
	}
}




int main(void)
{
	EXTI_PinConfig_t EXTIConfig;
	EXTIConfig.EXTI_GPIO_Port   = GPIOB;
	EXTIConfig.EXTI_Input_Line 	= EXTI_9;
	EXTIConfig.EXTI_Enable 		= EXTI_IRQ_ENABLE;
	EXTIConfig.EXTI_Trigger		= EXTI_TRIGGER_RISING;
	EXTIConfig.IRQ_CallBackPtr 	= CallBackFunction;
	MCAL_EXTI_Init(&EXTIConfig);

	MainOS();
}


//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-
//									Functions Declarations
//-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*--*-*-*-*-*-*-*-*-*-*-*-

void MainOS()
{
	//Initialize the Main Stack (Start & End)
	_E_MSP = _S_MSP - MAIN_STACK_SIZE;

	//Initialize Task A (Start & End)
	_S_PSP_TaskA = (_E_MSP - 8);
	_E_PSP_TaskA = (_S_PSP_TaskA - TASK_A_STACK_SIZE);

	//Initialize Task B (Start & End)
	_S_PSP_TaskB = (_E_PSP_TaskA - 8);
	_E_PSP_TaskB = (_S_PSP_TaskB - TASK_B_STACK_SIZE);

	while(1)
	{
		__asm("nop");
		if(Task_Flag == TaskA_Running)
		{
			// Set the PSP register = _S_PSP_TaskA
			OS_SET_PSP(_S_PSP_TaskA);
			// Make the SP point to PSP (SP -> PSP)
			OS_SWITCH_SP_to_PSP();
			// Switch from privileged to unprivileged
			OS_SWITCH_to_Unpri();


			// Activate the task
			TaskA(1, 2, 3);
			// Terminate the task


			// Switch from unprivileged to privileged
			OS_Generate_Exception();
			// Make the SP point to MSP (SP -> MSP)
			OS_SWITCH_SP_to_MSP();
		}
		else if(Task_Flag == TaskB_Running)
		{
			// Set the PSP register = _S_PSP_TaskB
			OS_SET_PSP(_S_PSP_TaskB);
			// Make the SP point to PSP (SP -> PSP)
			OS_SWITCH_SP_to_PSP();

			// Switch from privileged to unprivileged
			OS_SWITCH_to_Unpri();


			// Activate the task
			TaskB(1, 2, 3, 4);
			// Terminate the task


			// Switch from unprivileged to privileged
			OS_Generate_Exception();
			// Make the SP point to MSP (SP -> MSP)
			OS_SWITCH_SP_to_MSP();
		}
	}

}

void TaskA(int a, int b, int c)
{
	a = b;
	c = b;
	b = a;
	return;
}

void TaskB(int a, int b, int c, int d)
{
	a = b;
	c = b;
	b = d;
	d = a;
	return;
}
