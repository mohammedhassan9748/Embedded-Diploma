/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "../Services/Platform_Types.h"
#include "../Services/stm32f103c6.h"
#include "../Services/Utils.h"
#include "../MCAL/Inc/GPIO.h"
#include "../MCAL/Inc/EXTI.h"
#include "../MCAL/Inc/USART.h"
#include "../MCAL/Inc/SPI.h"
#include "../MCAL/Inc/I2C.h"
#include "../MCAL/Inc/GPTM.h"
#include "../HAL/Inc/LCD.h"
#include "../HAL/Inc/keypad.h"
#include "../HAL/Inc/EEPROM.h"
#include "../HAL/Inc/SevenSegment.h"
#include "../HAL/Inc/Servo.h"

uint8_t IRQ_Flag = 0;

enum CPU_AccessLevel
{
	privileged,
	unprivileged
};

void SWITCH_CPU_AccessLevel(enum CPU_AccessLevel AccessLevel)
{
	switch(AccessLevel)
	{
	case privileged:
		// Reset Bit[0] in the CONTROL Register.
		__asm("mrs r3,CONTROL \n\t"
				"lsr r3,#0x1 \n\t"
				"lsl r3,#0x1 \n\t"
				"msr CONTROL,r3 \n\t"
		);
		break;
	case unprivileged:
		// Set Bit[0] in the CONTROL Register.
		__asm("mrs r3,CONTROL \n\t"
				"orr r3, r3,#0x1 \n\t"
				"msr CONTROL,r3 \n\t"
		);
		break;
	}
}

void CallBackFunction(void)
{
	IRQ_Flag = 1;

	// Switch back to privileged before returining back from interrupt to the previous running unprivileged mode.
	SWITCH_CPU_AccessLevel(privileged);
}

int main(void)
{
	EXTI_PinConfig_t EXTIConfig;
	EXTIConfig.EXTI_GPIO_Port   = GPIOB;
	EXTIConfig.EXTI_Input_Line 	= EXTI_9;
	EXTIConfig.EXTI_Enable 		= EXTI_IRQ_ENABLE;
	EXTIConfig.EXTI_Trigger		= EXTI_TRIGGER_RISING;
	EXTIConfig.IRQ_CallBackPtr 	= CallBackFunction;
	MCAL_EXTI_Init(&EXTIConfig);

	/* Switch to unprivileged mode after configuring the NVIC in the interrupts, because if we do so before the NVIC initialization,
	 	 the hardware fault HardFault will be called
	 	 */
	SWITCH_CPU_AccessLevel(unprivileged);

	while(1)
	{
		if(IRQ_Flag)
			IRQ_Flag = 0;

	}
}
